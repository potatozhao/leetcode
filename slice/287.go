/*
给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

示例 1:

输入: [1,3,4,2,2]
输出: 2
示例 2:

输入: [3,1,3,4,2]
输出: 3
说明：

不能更改原数组（假设数组是只读的）。
只能使用额外的 O(1) 的空间。
时间复杂度小于 O(n2) 。
数组中只有一个重复的数字，但它可能不止重复出现一次。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/find-the-duplicate-number
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/

package main

// 二分法定位
func findDuplicate(nums []int) int {
	if len(nums) <= 2 {
		return nums[0]
	}
	s := 1
	e := len(nums) - 1
	m := (s + e + 1) / 2
	for s < e {
		n := 0
		for i := range nums {
			if nums[i] < m && nums[i] >= s {
				n++
			}
		}
		if n > m-s {
			e = m - 1
		} else {
			s = m
		}
		m = (s + e + 1) / 2
	}
	return s
}



// 弗洛伊德的乌龟和兔子（循环检测）

/*
首先，如果从nums[0]开始沿着下标的方式来走，如果没有重复的数字，可能可以走出一条线，因为不可能回到0，所以最后一个节点应该的值应该是n，而不存在索引号为n的节点（因为是从0开始），所以中断了，就退出了。

但是这里的情况是，存在重复的节点，所以这样沿着nums[0]走会发生什么呢？
首先，必定不可能回到0，因为没有值是0的节点，其次，不可能像刚刚一样中断。
这是为什么呢，因为要中断，必然需要节点的值大于最大的索引，但因为有重复，节点的最大值小于等于索引的最大值，所以没有办法中断，所以必定是在一个循环之中。

也就是通过这条路，走着走着进入了一个循环。
可以举个例子，[1,2,3,4,5,3]这样，也就是会 1-2-3-4-5-3-4-5-3-4-5……也就是3-4-5-3这部分陷入了循环，可以发现，重复的地方也就是循环的起始点，也就是3，因为这个3有2个不同的点到达了它，所以造成了循环，它也就是2条路的交叉口。

接下来，用乌龟和兔的方法，假如乌龟一次走1步，兔一次走2步。

所有的情况都可以抽象成先经过i个节点到达重复节点，再进入到长度为S的循环圈中。

那么，如果乌龟和兔同时出发，他们会在哪里相遇呢？
一定是在这个圈中的某点，因为兔的速度是2，乌龟是1，相对速度是1，所以兔子一定能追上乌龟，在圈里的某处。

当乌龟走了距离i到达圈起始点时，兔子已经走了2i，那么兔子相对于乌龟来说是多远呢？也就是i-kS，也就是去掉兔子额外走的k圈。

这时，还是兔子追乌龟，它需要追多远呢？应该是圈剩下的距离，也就是S-（i-ks），也就是(k+1)S-i，也就是乌龟再走这么久，会被追上，这个位置非常巧妙，可以发现这里再经过i就会回到圈的起点，这就让我们想到，在这个地方让另一个乌龟从起点爬起，当起点的乌龟爬到圈起始点时，刚好原来的乌龟也会达到圈起始点，这样就能够得到圈起始点了，也就是重复的元素。

作者：jie-ju-wei-ming-ming
链接：https://leetcode-cn.com/problems/find-the-duplicate-number/solution/xun-huan-jian-ce-fang-fa-xi-shuo-by-jie-ju-wei-min/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

*/
func findDuplicate(nums []int) int {
    slow := nums[0]
    fast := nums[nums[0]]
    for slow != fast{
        slow = nums[slow]
        fast = nums[nums[fast]]
        if slow == fast{
            break
        }
    }
    fast = 0
    for fast !=slow{
        fast = nums[fast]
        slow = nums[slow]
    }
    return fast
}
